#' Generate Conditionally Independent `R`-Many MA(4) Varying Time Series of the Same Length (Version 2)
#'
#' @description
#' `generate_MA4_varyType2()` generates `R`-many time series where the MA(4) that is used as the base coefficients for the variation is `(-.3,-.6,-.3,.6)`. In this version of the data generation, only the first coefficient is changed, all other coefficients are left as is.
#' This is based on the MA(4) used in \insertCite{granados-garcia_brain_2022;textual}{HBEST}.
#' This is the data generation that is used in \insertCite{lee_hierarchical_2025;textual}{HBEST}.
#'
#' @details
#' The variation around the first base theta coefficient is generated by:
#' 1. Sample 1 value from a \eqn{N(0,1)} to use as a "mean".
#' 2. Calculate: `basetheta[1] + alpha * mu_r * abs(basetheta[1])` where `basetheta[1]` is the original first MA(4) coefficient; `mu_r` is the 1 sampled values from the \eqn{N(0,1)}; and `alpha` is the user-specified scalar that controls the variation around the first base coefficient.
#' 3. Generate: A new time-series using the new `theta` value from step 2.
#' 4. Repeat steps 1-3 `R`-many times.
#'
#' @param n A numeric vector that determines the length of the time series generated. Must contain `R`-many entries. Time series may be of different lengths.
#' @param R An optional scalar indicating the number of conditionally independent time series to be generated. (default is `1`).
#' @param burn An optional scalar indicating the amount of burn-in to be used with [stats::arima.sim()].  (default is `50`).
#' @param alpha An optional scalar specifying the variation wanted from the first base coefficient. (default is `0.05`).
#'
#' @returns The function returns a list containing:
#' \tabular{ll}{
#'   `ts_list` \tab returns an `R`-long list each containing an `(n[r]` \eqn{\times} `1)` matrix of the generated time series. \cr
#'   `theta_true` \tab returns a `(4` \eqn{\times} `R)` matrix of true generated MA(4) coefficients. \cr
#' }
#'
#' @export
#'
#' @examples
#' R <- 20
#' ## For time series of different lengths:
#' n <- c(rep(500, R / 2), rep(800, R / 2))
#' burn <- 50
#' alpha <- 0.05
#' ts <- generate_MA4_varyType2(n = n, R = R, burn = burn, alpha = alpha)$ts_list
#'
#' # plot the time series generated:
#' # create an empty plot
#' plot(
#'   x = c(), y = c(),
#'   xlim = c(0, 800),
#'   ylim = range(ts),
#'   main = "Example",
#'   ylab = "",
#'   xlab = "time"
#' )
#' for (r in 1:10) {
#'   lines(ts[[r]][, 1], col = "blue")
#' }
#' for (r in 11:R) {
#'   lines(ts[[r]][, 1], col = "red")
#' }
#'
#' ## Returns an R-long list object each with a (500 x 1) matrix object,
#' ## a (4 x 20) matrix of true MA(4) coefficients,
#' ## a scalar returning the alpha provided,
#' ## and a (4 x 20) matrix of the standard normal values generated for each R.
#'
generate_MA4_varyType2 <- function(n, R = 1, burn = 50, alpha = 0.05) {
  # create a list to store the time series
  ts_list <- vector(mode = "list", length = R)
  # create baseline thetas:
  basetheta <- c(-.3, -.6, -.3, .6)
  # create matrix to store "true" theta values
  theta_true <- matrix(basetheta, nrow = 4, ncol = R)
  # create vector to store mu_r values
  mu_r_gen <- rep(NA, length = R)
  # set AR parameter
  phi <- NULL
  for (r in 1:R) {
    # Take only the first theta from the baseline theta and vary that theta
    # sample from a N(0,1) to get a mu_r
    mu_r <- stats::rnorm(n = 1, mean = 0, sd = 1)
    # calculate: theta_r + alpha * |theta_r| * mu_r
    theta <- basetheta[1] + alpha * mu_r * abs(basetheta[1])
    # store MA(1) coefficient generated
    theta_true[1, r] <- theta
    # store mu_r
    mu_r_gen[r] <- mu_r
    # generate data
    ts_list[[r]] <- matrix(
      stats::arima.sim(
        model = list(ar = phi, ma = theta_true[, r]),
        n = n[r],
        sd = 1,
        n.start = burn
      ),
      ncol = 1
    )
  }
  return(list(
    "ts_list" = ts_list,
    "theta_true" = theta_true
  ))
}
